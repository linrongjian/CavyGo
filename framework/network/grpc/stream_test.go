package fastgrpc

import (
	"fastgameserver/fastgameserver/network/gamerpc"
	"net"
	"testing"
)

func expectedPort(t *testing.T, expected string, lsn gamerpc.Acceptor) {
	_, port, err := net.SplitHostPort(lsn.Addr())
	if err != nil {
		t.Errorf("Expected address to be `%s`, got error: %v", expected, err)
	}

	if port != expected {
		lsn.Close()
		t.Errorf("Expected address to be `%s`, got `%s`", expected, port)
	}
}

func TestGRPCZLGameRpcPortRange(t *testing.T) {
	tp := NewZLGameRpc()

	lsn1, err := tp.Listen(":44444-44448")
	if err != nil {
		t.Errorf("Did not expect an error, got %s", err)
	}
	expectedPort(t, "44444", lsn1)

	lsn2, err := tp.Listen(":44444-44448")
	if err != nil {
		t.Errorf("Did not expect an error, got %s", err)
	}
	expectedPort(t, "44445", lsn2)

	lsn, err := tp.Listen(":0")
	if err != nil {
		t.Errorf("Did not expect an error, got %s", err)
	}

	lsn.Close()
	lsn1.Close()
	lsn2.Close()
}

func TestGRPCZLGameRpcCommunication(t *testing.T) {
	tr := NewZLGameRpc()

	l, err := tr.Listen(":0")
	if err != nil {
		t.Errorf("Unexpected listen err: %v", err)
	}
	defer l.Close()

	fn := func(zlgsock gamerpc.Channel) {
		defer zlgsock.Close()

		for {
			var m gamerpc.GMessage
			if err := zlgsock.Recv(&m); err != nil {
				return
			}

			if err := zlgsock.Send(&m); err != nil {
				return
			}
		}
	}

	done := make(chan bool)

	go func() {
		if err := l.Accept(fn); err != nil {
			select {
			case <-done:
			default:
				t.Errorf("Unexpected accept err: %v", err)
			}
		}
	}()

	c, err := tr.Dial(l.Addr())
	if err != nil {
		t.Errorf("Unexpected dial err: %v", err)
	}
	defer c.Close()

	m := gamerpc.GMessage{
		Header: map[string]string{
			"X-Content-Type": "application/json",
		},
		Body: []byte(`{"proto": "Hello World"}`),
	}

	if err := c.Send(&m); err != nil {
		t.Errorf("Unexpected send err: %v", err)
	}

	var rm gamerpc.GMessage

	if err := c.Recv(&rm); err != nil {
		t.Errorf("Unexpected recv err: %v", err)
	}

	if string(rm.Body) != string(m.Body) {
		t.Errorf("Expected %v, got %v", m.Body, rm.Body)
	}

	close(done)
}
